unit Core;

interface

const
  TBMax: byte = 16; //учесть, что может быть и не квадратный!

  TBXMax: byte = 255;
  TBYMax: byte = 255;
  TBZMax: byte = 255;

type
  {Определяем воксель как байт, по ходу пьесы наверное надо будет менять
  на более большой тип или даже на массив, TVoxel=array of byte;}
  {Значения TVoxel начинаются с 1, 0 считается пустым вокселем}
  TVoxel=byte;

  TVoxPtr=record
    x: integer;
    y: integer;
    z: integer;
  end;

  {Базовый класс для узла сцены}
  TNode=Class
  public
    {Базовая функция для получения вокселя по координатам}
    function GetVox(x:integer; y:integer; z:integer): TVoxel; virtual; abstract;
    {Базовая процедура установки вокселя по координатам}
    procedure SetVox(x:integer; y:integer; z:integer; v:TVoxel); virtual; abstract;
    {Базовая функция получения вокселя по указателю, сдвигая указатель на одну позицию}
    function GetCurVox(): TVoxel; virtual; abstract;
    {Базовая функция смещения указателя текущего вокселя}
    procedure SetCurVoxPtr(ptr:TVoxPtr); virtual; abstract;
    {Базовая функция сброса указателя текущего вокселя}
    procedure ResetCurVoxPtr(); virtual; abstract;
    {Базовая функуция получения указателя на текущий воксель}
    function GetCurVoxPtr(): TVoxPtr; virtual; abstract;
    {Базовая функция отвечающая, достигнут ли конец данных, аналог EOF}
    function IsEndOfData(): boolean; virtual; abstract;
    {Базовые функции для получения размеров по осям}
    function GetXDim(): integer; virtual; abstract;
    function GetYDim(): integer; virtual; abstract;
    function GetZDim(): integer; virtual; abstract;
    {Функции для получения дополнительной информации}
    function GetGridSize(): integer; virtual; abstract;
    function GetMemoryUsed(): integer; virtual; abstract;
    {Конструктор}
    Constructor Create(sizex:integer; sizey:integer; sizez:integer); virtual; abstract;
  End;

  {Квадратный Узел сцены, где каждый воксель представлен байтом, т.е. 255
  значениями, представляет собой контейнер для трёхмерного массива из байтов}
  {Основная часть класса - массив воксельных данных, здесь представлен в виде
  трёхмерного массива байтов, однако наверное следует реализаовать при помощи
  указателей на память или ещё Бог знает чего для улучшенного быстродействия}
  TByteNode=Class(TNode)
  protected
    voxeldata: array[0..255] of array[0..255] of array[0..255] of byte; //данные
    var gridsizex, gridsizey, gridsizez: integer; //размеры сетки
    curvoxptr: TVoxPtr; //указатель на следующий воксель
    eod: boolean; //достигнут ли конец сетки
  public
    {Функции для получения размеров по осям}
    function GetXDim(): integer; override;
    function GetYDim(): integer; override;
    function GetZDim(): integer; override;
    {Функция для получения вокселя по трём координатам}
    function GetVox(x:integer; y:integer; z:integer): TVoxel; override;
    {Функция получения вокселя по указателю, сдвигая указатель на одну позицию}
    function GetCurVox(): TVoxel; override;
    {Функция смещения указателя текущего вокселя}
    procedure SetCurVoxPtr(ptr:TVoxPtr); override;
    {Функуция получения указателя на текущий воксель}
    function GetCurVoxPtr(): TVoxPtr; override;
    {Функция сброса указателя текущего вокселя}
    procedure ResetCurVoxPtr(); override;
    {Функция отвечающая, достигнут ли конец данных, аналог EOF}
    function IsEndOfData(): boolean; override;
    {Процедура установки вокселя по координатам}
    procedure SetVox(x:integer; y:integer; z:integer; v:TVoxel); override;
    {Процедура очистки ВСЕЙ сетки}
    procedure ClearGrid();
    {Процедура заливки всей сетки указанным значением}
    procedure FillGrid(v:TVoxel);
    {Процедура заливки всей сетки случайными значениями}
    procedure FillGridRand();
    {Функции для получения дополнительной информации}
    function GetGridSize(): integer; override;
    function GetMemoryUsed(): integer; override;
    {Конструктор с указанием размера}
    Constructor Create(sizex:integer; sizey:integer; sizez:integer); override;
  End;

  TScene=Class

  End;



implementation

{************************Класс TByteNode***************************************}
  {Конструктор, задающий размеры сетки, однако размера массива не меняет}
  Constructor TByteNode.Create(sizex:integer; sizey:integer; sizez:integer);
  begin
    //задаются значения сетки
    gridsizex:=sizex;
    gridsizey:=sizey;
    gridsizez:=sizez;
    //задаётся значение указателя на текущий воксель {0,0,0}
    curvoxptr.x:=0; curvoxptr.y:=0; curvoxptr.z:=0;
    eod:=false;
  end;

  {Процедура заполнеия вокселя - в данном случае байта по указанным координатам}
  {Добавлено: 04.10.2015; Стабильность: неизвестно}
  {Быстродействие: неизвестно Количество тактов: неизвестно}
  {Варианты оптимизации: сравнения значений, присвоения}
  procedure TByteNode.SetVox(x: Integer; y: Integer; z: Integer; v: Byte);
  begin
    {Проверка на адекватность значений}                                                //возможна оптимизация?
    if x >= gridsizex then Exit;
    if x < 0 then Exit;
    if y >= gridsizey then Exit;
    if y < 0 then Exit;
    if z >= gridsizez then Exit;
    if z < 0 then Exit;
    {Установка значения вокселя}
    voxeldata[x,y,z]:=v;
  end;

  {Процедура получения вокселя - в данном случае байта по указанным координатам}
  {Добавлено: 04.10.2015; Стабильность: неизвестно}
  {Быстродействие: неизвестно Количество тактов: неизвестно}
  {Варианты оптимизации: сравнения значений, присвоения}
  function TByteNode.GetVox(x: Integer; y: Integer; z: Integer): TVoxel;
  begin
    {Проверка на адекватность значений}                                                //возможна оптимизация?
    result:=0;
    if x >= gridsizex then Exit;
    if x < 0 then Exit;
    if y >= gridsizey then Exit;
    if y < 0 then Exit;
    if z >= gridsizez then Exit;
    if z < 0 then Exit;
    {Установка значения вокселя}
    result:=voxeldata[x,y,z];
  end;

  function TByteNode.GetCurVox(): TVoxel;
  begin
    //проверка на адекватность значений не производится
    result:=voxeldata[curvoxptr.x,curvoxptr.y,curvoxptr.z];
    //увеличить позицию указателя по x
    inc(curvoxptr.x);
    //проверить, не требуется ли выполнить переход
    if (curvoxptr.x>=gridsizex) and (not eod) then
    begin
      curvoxptr.x:=0;
      inc(curvoxptr.y);
      if curvoxptr.y>=gridsizey then
      begin
        curvoxptr.y:=0;
        inc(curvoxptr.z);
        if curvoxptr.z>=gridsizez then
          eod:=true;
      end;
    end
  end;

  function TByteNode.GetXDim();
  begin
    Result:=gridsizex;
  end;

   function TByteNode.GetYDim();
  begin
    Result:=gridsizey;
  end;

   function TByteNode.GetZDim();
  begin
    Result:=gridsizeZ;
  end;

  procedure TByteNode.SetCurVoxPtr(ptr:TVoxPtr);
  begin
    //asd
  end;

  procedure TByteNode.ResetCurVoxPtr();
  begin
    curvoxptr.x:=0; curvoxptr.y:=0; curvoxptr.z:=0;
    eod:=false;
  end;

  function TByteNode.GetCurVoxPtr(): TVoxPtr;
  begin
    Result:=curvoxptr;
  end;

  function TByteNode.IsEndOfData(): boolean;
  begin
    Result:=eod;
  end;

  procedure TByteNode.ClearGrid();
  var
    i,j,k:integer;
  begin
    for i := 0 to TBXMax do begin
      for j := 0 to TBYMax do begin
        for k := 0 to TBZMax do begin
          voxeldata[i,j,k]:=0;
        end;
      end;
    end;
  end;

  procedure TByteNode.FillGrid(v:TVoxel);
  var
    i,j,k:integer;
  begin
    ClearGrid();
    for i := 0 to gridsizex-1 do begin
      for j := 0 to gridsizey-1 do begin
        for k := 0 to gridsizez-1 do begin
          voxeldata[i,j,k]:=v;
        end;
      end;
    end;
  end;

  procedure TByteNode.FillGridRand();
  var
    i,j,k:integer;
    r:integer;
  begin
    ClearGrid();
    for i := 0 to gridsizex-1 do begin
      for j := 0 to gridsizey-1 do begin
        for k := 0 to gridsizez-1 do begin
          r:=1+Random(2);
          if r=1 then
            voxeldata[i,j,k]:=Random(255)
          else
            voxeldata[i,j,k]:=0;
        end;
      end;
    end;
  end;

  function TByteNode.GetGridSize(): integer;
  begin
  //       asd
  end;

  function TByteNode.GetMemoryUsed(): integer;
  begin
  //sdad
  end;

end.
